name: Build and Deploy .NET Service to AWS EC2

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

env:
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
  IMAGE_NAME: dotnet-service

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    # Create Dockerfile dynamically for .NET service
    - name: Create Dockerfile
      run: |
        cat > Dockerfile << 'EOF'
        # Build stage
        FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
        WORKDIR /src
        
        # Copy csproj and restore dependencies
        COPY *.csproj ./
        RUN dotnet restore
        
        # Copy everything else and build
        COPY . ./
        RUN dotnet publish -c Release -o /app/publish
        
        # Runtime stage
        FROM mcr.microsoft.com/dotnet/aspnet:8.0
        WORKDIR /app
        
        # Copy published app from build stage
        COPY --from=build /app/publish .
        
        # Create non-root user
        RUN groupadd -r dotnetuser && useradd -r -g dotnetuser dotnetuser
        RUN chown -R dotnetuser:dotnetuser /app
        USER dotnetuser
        
        # Expose port
        EXPOSE 6000
        
        # Health check
        HEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \
          CMD curl -f http://localhost:6000/health || exit 1
        
        # Set environment
        ENV ASPNETCORE_URLS=http://+:6000
        ENV ASPNETCORE_ENVIRONMENT=Production
        
        # Start the application
        ENTRYPOINT ["dotnet", "PMS.dll"]
        EOF
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
    
    - name: Login to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    
    - name: Build Docker image
      run: |
        docker build -t ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest \
                     -t ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
                     --build-arg BUILDKIT_INLINE_CACHE=1 .
    
    - name: Test Docker image
      run: |
        echo "ğŸ§ª Testing Docker image..."
        
        # Run container for testing
        docker run -d --name dotnet-service \
          -p 6000:6000 \
          -e ASPNETCORE_ENVIRONMENT=Development \
          ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest
        
        echo "â³ Waiting for container to start..."
        sleep 15
        
        # Check if container is still running
        if docker ps | grep -q dotnet-service; then
          echo "âœ… Container is running successfully!"
          
          # Test the health endpoint
          echo "ğŸŒ Testing health endpoint..."
          if curl -f http://localhost:6000/health; then
            echo "âœ… Health endpoint is responding correctly!"
          else
            echo "âš ï¸  Health endpoint test failed"
            docker logs dotnet-service
            docker stop dotnet-service
            docker rm dotnet-service
            exit 1
          fi
          
          echo "ğŸ“‹ Container logs:"
          docker logs --tail 20 dotnet-service
          
          docker stop dotnet-service
          docker rm dotnet-service
        else
          echo "âŒ Container crashed on startup!"
          echo "ğŸ“‹ Container logs:"
          docker logs dotnet-service 2>&1 || echo "No logs available"
          docker rm dotnet-service 2>/dev/null || true
          exit 1
        fi
    
    - name: Push Docker image to Docker Hub
      run: |
        docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest
        docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
    
    - name: Image digest
      run: echo "âœ… .NET service image pushed successfully!"

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') && github.event_name == 'push'
    
    steps:
    - name: Deploy to AWS EC2
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USERNAME }}
        key: ${{ secrets.EC2_SSH_KEY }}
        script: |
          echo "ğŸš€ Starting .NET service deployment on AWS EC2..."
          
          # Login to Docker Hub
          echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
          
          # Pull the latest image
          echo "ğŸ“¦ Pulling latest Docker image..."
          docker pull ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest
          
          # Stop and remove old container if exists
          echo "ğŸ›‘ Stopping old .NET container..."
          docker stop dotnet-service 2>/dev/null || true
          docker rm dotnet-service 2>/dev/null || true
          
          # Create Docker network if it doesn't exist (should already exist from other services)
          echo "ğŸŒ Setting up Docker network..."
          docker network create my-app-network 2>/dev/null || echo "Network already exists"
          
          # Run new .NET service container (NO PORT MAPPING - internal only)
          echo "â–¶ï¸  Starting new .NET service container..."
          docker run -d \
            --name dotnet-service \
            --network my-app-network \
            --restart unless-stopped \
            -e ASPNETCORE_ENVIRONMENT=Production \
            -e ASPNETCORE_URLS=http://+:6000 \
            ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest
          
          # Wait for container to start
          echo "â³ Waiting for container to initialize..."
          sleep 10
          
          # Check if container is running
          if docker ps | grep -q dotnet-service; then
            echo "âœ… .NET service container is running successfully!"
            docker ps | grep dotnet-service
          else
            echo "âŒ .NET service container failed to start!"
            echo "Container logs:"
            docker logs dotnet-service
            exit 1
          fi
          
          # Wait for app to fully start
          sleep 5
          
          # Test .NET service from within Docker network
          echo "ğŸŒ Testing .NET service via Docker network..."
          if docker run --rm --network my-app-network curlimages/curl:latest -f http://dotnet-service:6000/health >/dev/null 2>&1; then
            echo "âœ… .NET service is accessible via Docker network!"
          else
            echo "âš ï¸  Warning: .NET service not responding yet via Docker network"
            docker logs dotnet-service
          fi
          
          # Clean up old Docker images (keep last 3)
          echo "ğŸ§¹ Cleaning up old images..."
          docker images | grep "${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}" | tail -n +4 | awk '{print $3}' | xargs -r docker rmi -f 2>/dev/null || true
          
          # Show all running containers
          echo "ğŸ“Š Current running containers:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          
          echo "ğŸ‰ .NET service deployment completed successfully!"
    
    - name: Verify Deployment
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USERNAME }}
        key: ${{ secrets.EC2_SSH_KEY }}
        script: |
          echo "ğŸ” Verifying .NET service deployment..."
          
          # Wait a bit more for full startup
          sleep 3
          
          # Check container logs
          echo "ğŸ“‹ .NET service container logs:"
          docker logs --tail 30 dotnet-service
          
          # Check container health
          echo "ğŸ¥ Container health status:"
          HEALTH_STATUS=$(docker inspect dotnet-service --format='{{.State.Health.Status}}' 2>/dev/null || echo "no healthcheck")
          STATE_STATUS=$(docker inspect dotnet-service --format='{{.State.Status}}')
          echo "Health: $HEALTH_STATUS"
          echo "State: $STATE_STATUS"
          
          # Test .NET service via Docker network (simulate backend calling it)
          echo "ğŸ”— Testing .NET service via Docker network (as Node.js backend would)..."
          if docker run --rm --network my-app-network curlimages/curl:latest -f -s http://dotnet-service:6000/health >/dev/null 2>&1; then
            echo "âœ… .NET service is accessible via Docker network!"
            echo "Sample health response:"
            docker run --rm --network my-app-network curlimages/curl:latest -s http://dotnet-service:6000/health
          else
            echo "âš ï¸  Warning: .NET service not responding via Docker network"
            echo "Container may still be starting up..."
          fi
          
          # Check Docker network configuration
          echo "ğŸŒ Docker network configuration:"
          docker network inspect my-app-network --format='{{range .Containers}}{{.Name}}: {{.IPv4Address}}{{"\n"}}{{end}}'
          
          # Test from Node.js backend container if it exists
          if docker ps | grep -q backend-app; then
            echo "ğŸ”— Testing connection from Node.js backend to .NET service..."
            docker exec backend-app sh -c "curl -f http://dotnet-service:6000/health" 2>/dev/null && \
              echo "âœ… Node.js backend can reach .NET service!" || \
              echo "âš ï¸  Node.js backend cannot reach .NET service yet"
          fi
          
          echo "âœ… .NET service verification complete!"
    
    - name: Deployment notification
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ‰ âœ… .NET SERVICE DEPLOYMENT SUCCESSFUL!"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "ğŸ”§ .NET Service Configuration:"
          echo "   â€¢ Container: dotnet-service"
          echo "   â€¢ Internal Port: 6000"
          echo "   â€¢ Network: my-app-network (internal only)"
          echo "   â€¢ No direct external access (security best practice)"
          echo ""
          echo "ğŸŒ Access Methods:"
          echo "   â€¢ From Node.js Backend: http://dotnet-service:6000"
          echo "   â€¢ From any container in my-app-network"
          echo ""
          echo "ğŸ“ Integration with Node.js Backend:"
          echo "   In your Node.js code, call the .NET service using:"
          echo "   const response = await axios.get('http://dotnet-service:6000/api/endpoint');"
          echo ""
          echo "âœ¨ All services are now interconnected!"
          echo "   Frontend â† Nginx â†’ Backend â†’ .NET Service"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        else
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âŒ .NET SERVICE DEPLOYMENT FAILED!"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "Please check the logs above for error details."
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        fi